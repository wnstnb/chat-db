-- Create conversations table
CREATE TABLE IF NOT EXISTS conversations (
    id BIGSERIAL PRIMARY KEY, 
    title TEXT, -- Title of the conversation autogenerated by content
    conversation TEXT, -- JSON stored as string
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Create chat_call_info table
CREATE TABLE IF NOT EXISTS chat_call_info (
    id BIGSERIAL PRIMARY KEY,
    conversation_id BIGINT REFERENCES conversations(id),
    prompt_tokens INTEGER,
    completion_tokens INTEGER,
    total_tokens INTEGER,
    model_version TEXT,
    query_type TEXT, -- 'READ' or 'WRITE'
    execution_time REAL, -- in milliseconds
    status TEXT, -- 'success', 'error', etc.
    error_message TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Create a function to execute read-only queries
CREATE OR REPLACE FUNCTION execute_read_query(query_text TEXT, query_params JSONB DEFAULT '[]'::JSONB)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    result JSONB;
    query_type TEXT;
    dynamic_query TEXT;
    temp_table_name TEXT;
    column_names TEXT[];
    column_name TEXT;
    column_list TEXT;
BEGIN
    -- Extract the first word of the query to determine its type
    query_type := lower(split_part(trim(query_text), ' ', 1));
    
    -- Ensure this is a read-only query
    IF query_type != 'select' THEN
        RAISE EXCEPTION 'Only SELECT queries are allowed with this function';
    END IF;
    
    -- Log the query for debugging
    RAISE NOTICE 'Executing query: %', query_text;
    
    -- Special handling for GROUP BY queries
    IF query_text ILIKE '%GROUP BY%' THEN
        BEGIN
            -- Create a temporary table to store the results
            temp_table_name := 'temp_results_' || md5(random()::text);
            
            -- Create the temporary table
            EXECUTE 'CREATE TEMPORARY TABLE ' || temp_table_name || ' AS ' || query_text;
            
            -- Get the column names from the temporary table
            EXECUTE 'SELECT array_agg(column_name::text) FROM information_schema.columns WHERE table_name = $1'
                INTO column_names
                USING temp_table_name;
            
            -- Build a column list for the SELECT statement
            column_list := '';
            FOREACH column_name IN ARRAY column_names LOOP
                IF column_list != '' THEN
                    column_list := column_list || ', ';
                END IF;
                column_list := column_list || quote_ident(column_name);
            END LOOP;
            
            -- Select the data from the temporary table and convert to JSON
            EXECUTE 'SELECT json_agg(row_to_json(t)) FROM (SELECT ' || column_list || ' FROM ' || temp_table_name || ') t'
                INTO result;
            
            -- Drop the temporary table
            EXECUTE 'DROP TABLE IF EXISTS ' || temp_table_name;
            
            -- Handle NULL result (empty result set)
            IF result IS NULL THEN
                result := '[]'::jsonb;
            END IF;
            
            RETURN result;
        EXCEPTION
            WHEN OTHERS THEN
                -- Log the error for debugging
                RAISE NOTICE 'Error executing GROUP BY query: %, SQLSTATE: %', SQLERRM, SQLSTATE;
                
                -- Try a simpler approach
                BEGIN
                    -- For GROUP BY queries, try a simpler approach
                    EXECUTE 'SELECT json_agg(t) FROM (' || query_text || ') t' INTO result;
                    
                    -- Handle NULL result (empty result set)
                    IF result IS NULL THEN
                        result := '[]'::jsonb;
                    END IF;
                    
                    RETURN result;
                EXCEPTION
                    WHEN OTHERS THEN
                        -- Log the error for debugging
                        RAISE NOTICE 'Error executing simplified GROUP BY query: %, SQLSTATE: %', SQLERRM, SQLSTATE;
                        RETURN jsonb_build_object('error', SQLERRM);
                END;
        END;
    ELSE
        -- For simple queries, try direct execution
        BEGIN
            -- Execute the query directly and convert to JSON
            EXECUTE 'SELECT array_to_json(array_agg(row_to_json(t))) FROM (' || query_text || ') t' INTO result;
            
            -- Handle NULL result (empty result set)
            IF result IS NULL THEN
                result := '[]'::jsonb;
            END IF;
            
            RETURN result;
        EXCEPTION
            WHEN OTHERS THEN
                -- Log the error for debugging
                RAISE NOTICE 'Error executing direct query: %, SQLSTATE: %', SQLERRM, SQLSTATE;
                RETURN jsonb_build_object('error', SQLERRM);
        END;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        -- Log the error for debugging
        RAISE NOTICE 'Error in execute_read_query: %, SQLSTATE: %', SQLERRM, SQLSTATE;
        RETURN jsonb_build_object('error', SQLERRM);
END;
$$;

-- Create a function to execute write queries
CREATE OR REPLACE FUNCTION execute_write_query(query_text TEXT, query_params JSONB DEFAULT '[]'::JSONB)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    result JSONB;
    query_type TEXT;
    affected_rows INTEGER;
BEGIN
    -- Extract the first word of the query to determine its type
    query_type := lower(split_part(trim(query_text), ' ', 1));
    
    -- Ensure this is a write query
    IF query_type NOT IN ('insert', 'update', 'delete') THEN
        RAISE EXCEPTION 'Only INSERT, UPDATE, and DELETE queries are allowed with this function';
    END IF;
    
    -- Execute the query
    EXECUTE query_text;
    
    -- Get the number of affected rows
    GET DIAGNOSTICS affected_rows = ROW_COUNT;
    
    -- Return the result
    RETURN jsonb_build_object(
        'success', true,
        'affected_rows', affected_rows
    );
EXCEPTION
    WHEN OTHERS THEN
        RETURN jsonb_build_object('error', SQLERRM);
END;
$$;

-- Create sample tables for testing

-- Pages table
CREATE TABLE IF NOT EXISTS pages (
    id SERIAL PRIMARY KEY,
    filename TEXT,
    preprocessed TEXT,
    page_number INTEGER,
    image_width REAL,
    image_height REAL,
    lines TEXT,
    words TEXT,
    bboxes TEXT,
    normalized_bboxes TEXT,
    tokens TEXT,
    words_for_clf TEXT,
    processing_time REAL,
    clf_type TEXT,
    page_label TEXT,
    page_confidence REAL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Extracted data table
CREATE TABLE IF NOT EXISTS extracted2 (
    id SERIAL PRIMARY KEY,
    key TEXT,
    value TEXT,
    filename TEXT,
    page_label TEXT,
    page_confidence REAL,
    page_num INTEGER,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Entities table
CREATE TABLE IF NOT EXISTS entities (
    entity_id SERIAL PRIMARY KEY,
    entity_type TEXT,
    entity_name TEXT,
    additional_info TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Page-entity crosswalk table
CREATE TABLE IF NOT EXISTS page_entity_crosswalk (
    crosswalk_id SERIAL PRIMARY KEY,
    page_id INTEGER REFERENCES pages(id),
    entity_id INTEGER REFERENCES entities(entity_id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Insert sample data for testing

-- Insert sample entities
INSERT INTO entities (entity_type, entity_name, additional_info)
VALUES 
    ('person', 'John Smith', '{"age": 35, "occupation": "Engineer"}'),
    ('person', 'Jane Doe', '{"age": 42, "occupation": "Doctor"}'),
    ('person', 'Bob Johnson', '{"age": 28, "occupation": "Accountant"}'),
    ('person', 'Alice Williams', '{"age": 31, "occupation": "Lawyer"}'),
    ('person', 'Charlie Brown', '{"age": 45, "occupation": "Teacher"}'),
    ('person', 'Diana Miller', '{"age": 39, "occupation": "Architect"}'),
    ('person', 'Edward Davis', '{"age": 52, "occupation": "Consultant"}'),
    ('business', 'Company XYZ', '{"industry": "Technology", "founded": 2005}'),
    ('business', 'Company ABC', '{"industry": "Healthcare", "founded": 1998}'),
    ('business', 'AAA Inc.', '{"industry": "Finance", "founded": 2010}'),
    ('business', 'MM Corp', '{"industry": "Manufacturing", "founded": 1985}'),
    ('business', 'JJ LLC', '{"industry": "Retail", "founded": 2015}'),
    ('business', 'ZZ Enterprises', '{"industry": "Energy", "founded": 2000}')
ON CONFLICT DO NOTHING; 