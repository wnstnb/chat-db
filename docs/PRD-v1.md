# Chat-DB: Database Assistant Product Requirements Document (v1)

## Overview
Chat-DB is an application that utilizes assistant-ui to interact with a Supabase database. The assistant processes natural language requests, queries the database accordingly, and returns accurate, thoughtfully formatted results to users.

## Goals
- Create an intuitive interface for users to query and manipulate database content using natural language
- Provide accurate and well-formatted responses to database queries
- Support both read operations (queries) and write operations (CRUD)
- Maintain conversation history for future reference
- Ensure secure and validated database operations

## Technical Requirements

### 1. User Interface
- Implement using [assistant-ui](https://www.assistant-ui.com/examples/ai-sdk)
- Clean, responsive design that works across devices
- Support for displaying structured data (tables, lists) in addition to text responses
- Visual indicators for processing state and confirmation requests

### 2. Chat Persistence
#### 2.1 Conversations Table
```sql
conversations (
    id BIGSERIAL PRIMARY KEY, 
    title TEXT, -- Title of the conversation autogenerated by content
    conversation TEXT, -- JSON stored as string
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);
```

#### 2.2 Conversation Structure Example
```json
[
  {"role": "user", "content": "how many entities do we have in the DB?"}, 
  {"role": "assistant", "content": " total_entities\n             13"}, 
  {"role": "user", "content": "what are the different types of entities and their counts?"}, 
  {"role": "assistant", "content": "entity_type  entity_count\n     person             7\n   business             6"}, 
  {"role": "user", "content": "who are the people in the entities table?"}
]
```

#### 2.3 Chat Call Information
- Table: `chat_call_info`
- Purpose: Track metadata about each interaction with the AI model
- Structure:
```sql
chat_call_info (
    id BIGSERIAL PRIMARY KEY,
    conversation_id BIGINT REFERENCES conversations(id),
    prompt_tokens INTEGER,
    completion_tokens INTEGER,
    total_tokens INTEGER,
    model_version TEXT,
    query_type TEXT, -- 'READ' or 'WRITE'
    execution_time REAL, -- in milliseconds
    status TEXT, -- 'success', 'error', etc.
    error_message TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);
```

### 3. AI Model Configuration
- Model: `gpt-4o`
- Temperature: 0 (for consistent, deterministic responses)
- Context window: Sufficient to handle complex queries and database schema

### 4. Database Integration
- Platform: Supabase
- Schema: As defined in the database schema section
- Connection: Secure API integration with proper authentication

### 5. System Prompt
The system prompt should include:
- Complete database schema information
- Instructions for query formulation
- Guidelines for response formatting
- Rules for handling CRUD operations
- Example queries and responses

### 6. Response Requirements
- Support for both natural language explanations and structured data
- Ability to format results as tables, lists, or other appropriate structures
- Clear error messages when queries cannot be executed
- Citations of data sources when appropriate
- Confirmation requests for any data modification operations

### 7. Operation Types
#### 7.1 Read Operations
- Support for complex queries across multiple tables
- Ability to filter, sort, and aggregate data
- Natural language interpretation of query intent

#### 7.2 Write Operations (CRUD)
- Create, update, and delete operations on database records
- **Mandatory user confirmation** before executing any write operation
- Clear preview of changes before execution
- Rollback capability for failed operations

## Database Schema
The application will interact with the following database schema:

```sql
-- Pages table: Stores information about document pages
Table: pages(
    filename TEXT,          -- File name of the uploaded document
    preprocessed TEXT,      -- File path of a page's final preprocessed image
    page_number INTEGER,    -- Page number in the document
    image_width REAL,       -- Width of the page image
    image_height REAL,      -- Height of the page image
    lines TEXT,             -- Extracted lines of text
    words TEXT,             -- Extracted words
    bboxes TEXT,            -- Bounding boxes of words
    normalized_bboxes TEXT, -- Normalized bounding boxes
    tokens TEXT,            -- Extracted tokens
    words_for_clf TEXT,     -- Words used for classification
    processing_time REAL,   -- Time taken for processing
    clf_type TEXT,          -- Type of classifier used
    page_label TEXT,        -- Predicted label for the page
    page_confidence REAL,   -- Confidence score for the label
    created_at DATETIME default current_timestamp -- Timestamp of creation
)

-- Extracted data table: Stores key-value pairs from documents
Table: extracted2(
    key TEXT,           -- Designated key extracted from the page
    value TEXT,         -- Extracted value corresponding to the key
    filename TEXT,      -- Foreign key to pages.preprocessed
    page_label TEXT,    -- Type of page -- corresponds to pages.page_label
    page_confidence REAL, -- Confidence score of page_label
    page_num INTEGER,   -- Page number in the document
    created_at DATETIME default current_timestamp -- Timestamp of creation
)

-- Entities table: Stores unique person or business entities
Table: entities(
    entity_id INTEGER PRIMARY KEY AUTOINCREMENT,
    entity_type TEXT,         -- 'person' or 'business'
    entity_name TEXT,         -- Full name or business name
    additional_info TEXT,     -- JSON or additional metadata
    created_at DATETIME default current_timestamp -- Timestamp of creation
)

-- Page-entity crosswalk: Links pages to entities (many-to-many)
Table: page_entity_crosswalk(
    crosswalk_id INTEGER PRIMARY KEY AUTOINCREMENT,
    page_id INTEGER,          -- Foreign key to pages
    entity_id INTEGER,        -- Foreign key to entities
    created_at DATETIME default current_timestamp -- Timestamp of creation
)
```

## Example Queries and Responses
The system should be able to handle queries similar to the following examples:

### Example 1: Tax Return Data Query
**User Query:**
"Show me tax return data on Company XYZ for the last 3 years. Exclude balance sheet items."

**Expected SQL:**
```sql
SELECT e.filename,
       e.key,
       e.value,
       e.page_label,
       p.created_at,
       ent.entity_name
FROM extracted2 e
JOIN pages p ON e.filename = p.preprocessed
JOIN page_entity_crosswalk pc ON p.id = pc.page_id
JOIN entities ent ON pc.entity_id = ent.entity_id
WHERE ent.entity_name = 'Company XYZ'
  AND p.created_at >= DATE('now', '-3 years')
  AND e.page_label NOT IN ('1120S_bal_sheet', '1065_bal_sheet', '1120_bal_sheet')
ORDER BY p.created_at DESC;
```

### Example 2: Insurance Property Address
**User Query:**
"What is the insured property address for Company ABC's insurance?"

**Expected SQL:**
```sql
SELECT DISTINCT e.filename,
       MAX(CASE WHEN e.key = 'property_address' THEN e.value END) AS property_address,
       ent.entity_name
FROM extracted2 e
JOIN pages p ON e.filename = p.preprocessed
JOIN page_entity_crosswalk pc ON p.id = pc.page_id
JOIN entities ent ON pc.entity_id = ent.entity_id
WHERE ent.entity_name = 'Company ABC'
  AND e.page_label IN ('acord_28', 'acord_25')
GROUP BY e.filename, ent.entity_name;
```

### Example 3: Lease Terms Query
**User Query:**
"Does AAA Inc. have a lease? What are the lease terms on it?"

**Expected SQL:**
```sql
SELECT e.filename,
       MAX(CASE WHEN e.key = 'lease_start_date' THEN e.value END) AS lease_start_date,
       MAX(CASE WHEN e.key = 'lease_end_date' THEN e.value END) AS lease_end_date,
       MAX(CASE WHEN e.key = 'term_length' THEN e.value END) AS term_length,
       ent.entity_name
FROM extracted2 e
JOIN pages p ON e.filename = p.preprocessed
JOIN page_entity_crosswalk pc ON p.id = pc.page_id
JOIN entities ent ON pc.entity_id = ent.entity_id
WHERE ent.entity_name = 'AAA Inc.'
  AND e.page_label = 'lease_document'
GROUP BY e.filename, ent.entity_name;
```

### Example 4: Complex Multi-Table Query
**User Query:**
"Who are the owners of MM Corp, and do we have drivers licenses for them?"

**Expected SQL:**
```sql
WITH owners AS (
    SELECT DISTINCT e.filename,
           e.value AS owner_name
    FROM extracted2 e
    JOIN pages p ON e.filename = p.preprocessed
    JOIN page_entity_crosswalk pc ON p.id = pc.page_id
    JOIN entities ent ON pc.entity_id = ent.entity_id
    WHERE ent.entity_name = 'MM Corp'
      AND e.key = 'shareholder_name'
      AND e.page_label IN ('1120S_k1', '1065_k1')
),
drivers AS (
    SELECT DISTINCT ent.entity_name AS person_name
    FROM extracted2 e
    JOIN pages p ON e.filename = p.preprocessed
    JOIN page_entity_crosswalk pc ON p.id = pc.page_id
    JOIN entities ent ON pc.entity_id = ent.entity_id
    WHERE e.page_label = 'drivers_license'
      AND ent.entity_type = 'person'
)
SELECT o.owner_name,
       CASE WHEN d.person_name IS NOT NULL THEN 'Yes' ELSE 'No' END AS has_drivers_license
FROM owners o
LEFT JOIN drivers d ON o.owner_name = d.person_name;
```

### Example 5: Certificate of Good Standing
**User Query:**
"Do we have a certificate of good standing for JJ LLC?"

**Expected SQL:**
```sql
SELECT e.filename,
       MAX(CASE WHEN e.key = 'business_name' THEN e.value END) AS business_name,
       MAX(CASE WHEN e.key = 'current_standing' THEN e.value END) AS current_standing,
       MAX(CASE WHEN e.key = 'date_incorporated' THEN e.value END) AS date_incorporated,
       ent.entity_name
FROM extracted2 e
JOIN pages p ON e.filename = p.preprocessed
JOIN page_entity_crosswalk pc ON p.id = pc.page_id
JOIN entities ent ON pc.entity_id = ent.entity_id
WHERE ent.entity_name = 'JJ LLC'
  AND e.page_label = 'certificate_of_good_standing'
GROUP BY e.filename, ent.entity_name;
```

## Implementation Timeline
1. **Phase 1: Setup and Basic Functionality**
   - Implement UI using assistant-ui
   - Set up Supabase connection
   - Create basic chat interface
   - Implement conversation persistence

2. **Phase 2: Query Capabilities**
   - Develop system prompt with schema information
   - Implement read-only query functionality
   - Add response formatting for structured data

3. **Phase 3: CRUD Operations**
   - Add write operation capabilities
   - Implement confirmation workflow for data modifications
   - Add rollback functionality

4. **Phase 4: Testing and Refinement**
   - Comprehensive testing with example queries
   - Performance optimization
   - UI/UX refinements

## Success Metrics
- Query accuracy rate (% of queries correctly interpreted and executed)
- Response quality (clarity, formatting, completeness)
- User satisfaction metrics
- System performance (response time, token usage efficiency)
- Error rate and recovery effectiveness 